# Signatures

## What are signatures in Filecoin

Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages among with the assurance that each message was generated by specific individuals. In other words, it is infeasible for another individual i to generate a signed message that appears to have been generated by j.

We use signatures in filecoin to verify *something* was done by *someone*. For example, we use signatures in order to validate deal messages which represent an action like a storage deals We also use signatures to determine who generated a particular message, determine public keys--which can be recovered from signed data and a signature, and find filecoin addresses which generated from a public key.

- Messages (From actors to the blockchain)
- Tickets (Signature of proof - [Mining](mining.md)
- Block signature (Signature over all data in the block - done by block leader)

## What signatures affect

What uses them

- [Messages](https://github.com/filecoin-project/specs/blob/master/data-structures.md)
- Block validation
- Tickets [TODO: link to EC spec; inform leader election in Expected Consensus (EC)]

Note that messages between actors are not signed. This is an unfortunate namespace collision. Messages between actors are always spawned by a message from a user. In this way, signed messages are containers for messages between actors.

## Dependencies

Things that affect Filecoin signatures

- Elliptic curve implementations
  - ECDSA with secp256k1 (BitCoin-style elliptic curve)
  - BLS12-381 for BLS signatures and aggregation. 
    - Described as *Variant 1* in [IETF BLS Signature Scheme](https://tools.ietf.org/html/draft-boneh-bls-signature-00)
    - Small signature size
    - Larger public keys
- Signature size limits
  - ECDSA - 64 bytes + 1 byte for public key recovery
  - BLS Signatures - 48 Bytes
- Avg. processing power available to a CPU 
  - Affects ability to verify signature aggregates
  - Each signature or collection of signatures should be validated with no impact to the consumption of the chain


## Non-Dependencies

Does not affect

- Transport encryption
- File encodings (PoRep)

## Interface

Filecoin requires a system that fulfils the following interface to function correctly.

Note: `Message` is used here as the object being signed, but this interface should also work for other things that need to be signed. 

```go
type Signature interface {

        // Sign generates a proof that miner `M` generated or approved of message `msg`.
        //
        // Out:
        //   sig - a series of bytes representing a signature  
        //   err - a standard error message indicating any process issues
        // In:
        //   msg - a series of bytes representing a message to be signed
  		  //   addr - the Filecoin `Address` of the signer
        //   sk - a private key which cryptographically links `M` to `sig`
        //
        Sign(msg Message, addr Address, sk PrivateKey) (sig SignatureBytes, err error)
        
        // Aggregate generates a BLS signature aggregate from a set of BLS 
        // signatures. Associated `Address` must be passed to this function
  		  // so that the aggregate can be verified. This function will pair a `sig` 
  			// with an `Address` based on index in `sigs` and `addresses`.
        //
        // Out:
        // 	 sig - a series of bytes representing a single BLS signature
        //   err - a standard error message indicating any process issues
        // In:
     		//   sigs - an array of SignatureBytes {sig_1, sig_2..., sig_n}
    		//   addrs - an array of Addresses {address_sig_1, address_sig_2..., address_sig_n}
  			//
  			Aggregate(sigs []SignatureBytes, addrs []Address)(sig SignatureBytes, err error)
  
  			// Verify validates the statement: only `M` could have generated `sig`
        // given the validator has a message `m`, a signature `sig`, and a
        // public key `pk`.
        //
        // Out:
        //   valid - a boolean value indicating the signature is valid
        //   err - a standard error message indicating any process issues
        // In:
  			//   smsg - a SignedMessage which contains {Message, Address, SignatureBytes}
        //   pk - a Public Key of the appropriate type
        //
        Verify(smsg SignedMessgage, pk PublicKey) (valid bool, err error)
  
  			// VerifyAggregate validates a collection of statements that are represeted by 
  			// a signature aggregate: "For each M_i and PK_i in smsgs, only this collection 
  			// of {M}, {PK}, and signers could have generated `smsgs.SignatureBytes`
  			//
        // Out:
        //   valid - a boolean value indicating the signature is valid
        //   err - a standard error message indicating any process issues
        // In:
        //   smsgs - a SignedMessage which contains {[]Message, []Address, SignatureBytes}
        //   pks - an array of Public Keys of the appropriate type associated with a message
  			// 	 at index `i` in []Message.
        //
  			VerifyAggregate(smsgs SignedMessgage,  pks []PublicKeys) (valid bool, err error)

        // Recover determines the public key associated with a particular signature. For
  			// ECDSA signatures public keys can be recovered from SignatureBytes and an
  			// associated message. For BLS signatures, public keys will be recovered by lookup 
  			// using a mapping from Address to public key.
        //
        // Out:
        //    pk - the public key associated with `M` who signed `msg`
        //    err - a standard error message indicating any process issues
        //    **
        // In:
        //    msg - a series of bytes representing the signed message
        //    sig - a series of bytes representing a signature
        //
        Recover(msg Message, addr Address, sig SignatureBytes) (pk PublicKey, err error)
}
```

### Signed Message

This is the container for a signature that combines a message with an address and signature. 

```go
Type SignedMessage Struct {

		// Addrs is an array of Addresses associated with a particular message in Msgs 
  	// at the same index. Each Address tracks the ID of the actor responsible for 
  	// signing a particular Msg. An ID can be converted into a public key via 
  	// Address.GetPublicKey(ID).
		//
		Addrs []Address `JSON`

  	// Msgs is an array of messages. Each message in Msgs is represented by raw bytes.
  	// Each message in Msgs will correspond to an Address in Addrs by index. 
  	//
    Msgs []bytes `JSON`   

  	// Sig is a cryptographic signature that was generated according to the type 
  	// reflected in Address.
    Sig SignatureBytes `JSON` 
    
}
```

## Key Generation & Elliptic Curve Parameters

This specification assumes the implementer uses a strong cryptographic pseudorandom generator `RANDOM`. The following was adapted from [IETF BLS Signature Scheme - Keygen](https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.2). 

```go
Input: RANDOM
Output: PK, SK

   1.  SK = x, chosen as a random integer in the range 1 and r-1
   2.  PK = x*P, P is an element of an elliptic curve E
   3.  Output PK, SK
```

For ECDSA, `P` is the generator for `E`. For BLS, we choose `P` to be a generator in `E2` which is the larger of the elliptic curve groups.

### BLS12-381 Parameter Choices

We have chosen to use the same elliptic curve parameters as [zkcrypto/pairing](https://github.com/zkcrypto/pairing/tree/master/src/bls12_381) with the exception that we are signing in G1 and generating public keys in G2. Note: there is a namespace collision between [zkcrypto/pairing](https://github.com/zkcrypto/pairing/tree/master/src/bls12_381) and [IETF BLS Signature Scheme](https://tools.ietf.org/html/draft-boneh-bls-signature-00) concerning G1 and G2. In zkcrypto/paring, G1 and G2 are points defined in the largest prime order subgroup of the elliptic curve defined by BLS12-381. In the IETF BLS Signature Scheme, G1 and G2 represent the largest prime order subgroups in BLS12-381. We will comply with the IETF standard. We will denote the generators of G1 and G2 as P1 and P2 respectively. E1 and E2 will denote the elliptic curve defined by BLS12-381.

```go
q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab

r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001

P1:
x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507
y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569

P2:
x = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758*u + 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160
y = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582*u + 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905

```

[TODO: add notes on point compression and effect on serialization]

## Signing a Message

### `Sign` via ECDSA (using [libsecp256k1](https://github.com/bitcoin-core/secp256k1))

### `Sign` via BLS (taken from [IETF BLS Signature Scheme - Sign](https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.3) with BLS12-381)

```go
Input: SK = x, h(msg)       
Output: sigma

	 1.  Input a secret key SK = x and a h(msg)
	 2.  H = hash_to_G1(suite_string, h(msg))
   3.  Gamma = x*H
   4.  sigma = E1_to_string(Gamma)
   5.  Output sigma
```

Where h(msg) is the output of a cryptographic hash function and sigma is the notation for BLS signature.

## Aggregating Signed Messages

Pairing-based signatures allow a user to represent a collection of signatures as a single element in the base group. In other words, we can take a collection of signatures and "add" them together into a single value that is the same size as a single signature. We call this process Signature Aggregation. The result of this operation is called the Aggregate Signature which has the same general properties as any other pairing-based Signature. Some security [considerations](https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html).

### Aggregation Process (taken from [IETF BLS Signature Scheme - Aggregate](https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.5) )

```go
Input: (PK_1, sigma_1), ..., (PK_n, sigma_n)    
Output: sigma

   1.  Output sigma = sigma_1 + sigma_2 + ... + sigma_n
```

Where `sigma_i` is a Signature with associated public key  `PK_i`. `sigma` is the Aggregate Signature and will be represented by `SignatureBytes`. `+` is point addition as defined by the cryptographic group.

## Verifying Signed Messages

In order to communicate to `Verify` what kind of verification algorithm to use, Verify must accept `SignedMessage` as input. 

**Determining Signature Type**

`SignedMessage.Address` will inform `Verify` if the `SignedMessage.SignatureBytes` is a BLS or ECDSA signature. `Verify` will infer this data from the `Address.protocol` field. 

```go
Input: Address
Output: "BLS", "ECDSA", or "INVALID"
   
   1.  If Address.protocol = 0 output "BLS" and stop
   2.  If Address.protocol = 1 output "ECDSA" and stop
   3.  If Address.protocol = 3 output "BLS" and stop
	 4.  If Address.protocol != {0 OR 1 OR 3} output "INVALID"
```

**Determining if the signature is a Signature Aggregate**

If there is more then one message in `SignedMessage.Msgs` then the `SignedMessage` is assumed to be a signature aggregate. If `Address` is empty then `Verify` will assume the `SignedMessage` is a signature aggregate. The procedure below uses `len()` to indicate a function that returns the number of elements in an array.

```go
Input: SignedMessage
Output: "Aggregate" or "INVALID"
   
	 1.  If SignedMessage.Address[i].protocol != {0 OR 3} for all i output "INVALID" and stop
	 2.  If len(SignedMessage.Msgs) > 1 output "Aggregate" else output "INVALID"
```

### `Verify` via ECDSA (using [libsecp256k1](https://github.com/bitcoin-core/secp256k1))

### `Verify` via BLS (adapted from [IETF BLS Signature Scheme - Verify](https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.4) with BLS12-381)

In each of the algorithms described below, the public keys were recovered via the `Recover` method. The procedures below use `len()` to indicate a function that returns the number of elements in an array.

**Verify a single signature using `Verify`**

```go
Input: PK, msg, sigma    
Output: "VALID" or "INVALID"
   
	 0.  If len(SignedMessage.Msgs) != 1, output "INVALID"
   1.  H = hash_to_G1(suite_string, msg)
   2.  Gamma = string_to_E1(sigma)
   3.  If Gamma is "INVALID", output "INVALID" and stop
   4.  If r*Gamma != 0, output "INVALID" and stop
   5.  Compute c = e(Gamma, P2)
   6.  Compute c* = e(H, PK)
   7.  If c and c* are equal,	output "VALID", else output "INVALID"
```

**Verify a signature aggregate using `VerifyAggregate`**

Note that mapping a message to a public key is done via index. In other words and given a `SignedMessage`, `PK_i` corresponding to `msg_i = SignedMessage.Msgs[i] ` can be found be performing `Recover(SignedMessage.Msgs[i], SignedMessage.Address[i], NULL)`.

```go
Input: (PK_1, msg_1), ..., (PK_n, msg_n), sigma
Output: "VALID" or "INVALID"

   1.  H_i = hash_to_G1(suite_string, msg_i)
   2.  Gamma = string_to_E1(sigma)
   3.  If Gamma is "INVALID", output "INVALID" and stop
   4.  If r*Gamma != 0,	output "INVALID" and stop
   5.  Compute c = e(Gamma, P2)
   6.  Compute c* = e(H_1, PK_1) * ... * e(H_n, PK_n)
	 7.  If c and c* are equal, output "VALID", else output "INVALID"

```

## Recovering a public key

### ECDSA Recovery

[TODO: [Reference](http://www.secg.org/sec1-v2.pdf))

### BLS Recovery

[TODO: Add algorithm]

## Selected Signature Scheme

Currently, Filecoin uses ECDSA (curve secp256k1) or BLS (curve BLS12-381) signatures to fulfill the above interface. All signatures on messages, blocks, and tickets use the same scheme and format.

### Wire Format

What bits are on the wire and in what order/format. We are currently adhering to libsecp256k1 serialization for ECDSA but will not list that wire format here. We do point to the code where an authoritative format is defined.

**ECDSA**

Follow: <https://github.com/bitcoin-core/secp256k1/blob/314a61d72474aa29ff4afba8472553ad91d88e9d/src/ecdsa_impl.h#L177>

**BLS (Taken from  [IETF BLS Signature Scheme - Type Conversions](https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.6.2))**

(TODO: [Reference](https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.6.2))

## Github References

<https://github.com/filecoin-project/specs/issues/131>

[go-filecoin SignedMessage](https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go)

[go-filecoin signer](https://github.com/filecoin-project/go-filecoin/blob/master/types/signer.go)

## References & Notes

Signatures are not sent over the wire on their own, instead they are encapsulated in in a [SignedMessage](https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go#L22-L28). Each `SignesMessage` contains a `Message`, `Address`, and a signature. `SignedMessage` is sent over the wire by marshaling it to cbor and send, once it is received it is unmarshaled form [cbor](http://cbor.io/) back into the `SignedMessage` Structure.
[Code for marshaling and unmarshaling SignedMessages](https://github.com/filecoin-project/go-filecoin/blob/master/types/signed_message.go#L22-L38)

- Notes on ECDSA public key recovery. Public key recovery is an operation that allows one to compute a public key from a message and signature. Typically this increases the signature size by at least 1 bit.
  - [Creating a recoverable signature in libsecp256k1](https://github.com/ipsn/go-secp256k1/blob/9d62b9f0bc52d16160f79bfb84b2bbf0f6276b03/libsecp256k1/include/secp256k1_recovery.h#L70)
  - [Ethereum ECDSA Recovery - Medium](https://medium.com/@libertylocked/ec-signatures-and-recovery-in-ethereum-smart-contracts-560b6dd8876)
  - [Crypto Stack Exchange](https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work/18106#18106)
  - SECG Org - [4.1.6 Public Key Recovery Operation Page 47](http://www.secg.org/sec1-v2.pdf)

- secp256k1 signature serialization
  - [secp256k1 recoverable signature](https://github.com/ethereum/ethash/blob/f5f0a8b1962544d2b6f40df8e4b0d9a32faf8f8e/vendor/github.com/ethereum/go-ethereum/crypto/secp256k1/libsecp256k1/include/secp256k1_recovery.h#L55)
  - [secp256k1 general signatures](https://github.com/bitcoin-core/secp256k1/blob/314a61d72474aa29ff4afba8472553ad91d88e9d/src/ecdsa_impl.h#L177)
  - [Go-filecoin implementation](https://github.com/filecoin-project/go-filecoin/blob/e95bde8ff289b0c88d748e92b1bcca99ecc403cb/crypto/secp256k1/secp256.go#L98)
- [golang implementation of secp256k1 point compression](https://github.com/btcsuite/btcd/blob/86fed781132ac890ee03e906e4ecd5d6fa180c64/btcec/signature.go#L338)

## Inspiration

JSON Web Sigs/Keys: <https://tools.ietf.org/html/rfc7515>

NIST Signature Standard: <https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf>
